* 选择

** 数据结构 1~11

   1. c
   2. c
   3. b
   4. c
   5. c
   6. d
      - a
      - 一定连通?
   7. d
   8. b
   9. d
      - c
      - 十字链表: 有向图
      - 邻接多重表: 无向图
   10. c
   11. c

** 计算机组成原理 12~22

   1. c
   2. d
   3. c
      - 基数为 4 浮点数规格化: 小数点后两位不为零: 00
   4. b
   5. d
   6. d
   7. b
      - c
        - risc 不可能兼容 cisc
        - risc 主要目标是减少指令数?
   8. a
   9. b
   10. d
   11. b

** 操作系统 23~32

   1. c
   2. d
   3. b
   4. a
      - b
      - 饥饿? 概率上没有
   5. b
   6. c
   7. d
      - 访问由 _权限和文件属性_ 共同限制, 不是用户优先级
      - 权限和属性不是一个东西?
      - 存取控制矩阵: 多个用户间的存取权限保护
   8. d
   9. c
   10. c

** 计算机网络 33~40

   1. d
   2. a
   3. c
   4. c
   5. c
   6. c
   7. a
   8. c

* 大题

** 41

*** 41.1

    若不唯一, 则假设 t1 和 t2 是两个不同的最小生成树, 另 t3 为 t1 与 t2 的并,
    则 t3 中必定有环, 环中必定有唯一最大边, 设 t1 包含该边, 则与 t1 为最小生成树矛盾.

*** 41.2

    不一定. 就算是同一种算法, 选择不同最小生成树不同.

*** 41.3

    |   |  1 |  2 |  3 |    4 |    5 |
    |---+----+----+----+------+------|
    | 1 |    | 70 | 60 |   90 |      |
    | 2 | 70 |    | 80 |   40 |   40 |
    | 3 | 60 | 80 |    |   60 |      |
    | 4 | 90 | 40 | 60 |      | [20] |
    | 5 |    | 40 |    | [20] |      |

    |  45 |  1 |    2 |  3 |  [4] | [5] |
    |-----+----+------+----+------+-----|
    |   1 |    |   70 | 60 |   90 |     |
    |   2 | 70 |      | 80 | [40] |  40 |
    |   3 | 60 |   80 |    |   60 |     |
    | [4] | 90 | [40] | 60 |      |     |
    | [5] |    |   40 |    |      |     |

    | 245 |  1 | [2] |    3 | [4]  | [5] |
    |-----+----+-----+------+------+-----|
    |   1 |    |  70 |   60 | 90   |     |
    | [2] | 70 |     |   80 |      |     |
    |   3 | 60 |  80 |      | [60] |     |
    | [4] | 90 |     | [60] |      |     |
    | [5] |    |     |      |      |     |

    | 2345 |    1 | [2] | [3]  | [4] | [5] |
    |------+------+-----+------+-----+-----|
    | 1    |      |  70 | [60] |  90 |     |
    | [2]  |   70 |     |      |     |     |
    | [3]  | [60] |     |      |     |     |
    | [4]  |   90 |     |      |     |     |
    | [5]  |      |     |      |     |     |

    |   |  1 |  2 |  3 |  4 |  5 |
    |---+----+----+----+----+----|
    | 1 |    |    | 60 |    |    |
    | 2 |    |    |    | 40 |    |
    | 3 | 60 |    |    | 60 |    |
    | 4 |    | 40 | 60 |    | 20 |
    | 5 |    |    |    | 20 |    |

** 42

   #+begin_src cpp
     #include <vector>
     #include <iostream>
     #include <numeric>

     using namespace std;

     int func (vector<int> &v) {
       int s = v.size();
       vector<int> dp(s-1);
       dp[0] = v[0];
       for (int i = 1; i < s-1; ++i)
         dp[i] = max(v[i], dp[i-1]);
       int m = v[s-1];
       int c = dp[s-2] - m;
       for (int i = s-3; i >= 0; --i) {
         m = min(v[i+1], m);
         int tmp = dp[i]-m;
         if (tmp > c)
           c = tmp;
       }
       return c;
     }

     int main() {
       vector<int> a {2, 4, 1, 16, 7, 5, 11, 9};
       cout << func(a);
       return 0;
     }
   #+end_src

   #+RESULTS:
   : 11

** 43
   : 只有真正的加法才有溢出: [+]+[+], [-]+[-], 其他情况下无论是否有进位均无溢出, 符号位改变为溢出, 未改变为未溢出

*** 43.1

    - a
      - 原码: 1100 0100
      - 反码: 1011 1011
      - 补码: 1011 1100
    - b
      - 原码: 1101 0000
      - 反码: 1010 1111
      - 补码: 1011 0000

*** 43.2

    - c

      | 1011 1100 |
      | 1011 0000 |
      |-----------|
      | 0110 1100 |

    - of: 1, sf: 0, cf: 1

*** 43.3

    - d

      | 1011 1100 |
      |-----------|
      | 1101 0000 |
      |-----------|
      | 0101 0000 |
      | 1011 1100 |
      |-----------|
      | 0000 1100 |

    - _of: 0_, sf: 0, cf: 1

** 44

*** 44.1

    - pc/iar: log(16384) = 14
    - ir/idr: 18
    - dar: log(65536) = 16
    - r1~7/ac01: 16

*** 44.2

    - pc->iar, pcout, iarin
    - im->idr, 读im, idrin
    - idr->ir, idrout, irin
    - pc->pc+1
    - r1+x->ac1, +, r1out, xout, ac1in
    - ac1->dar, ac1out, darin
    - dm->ddr, 读dm, ddrin
    - ddr+ac0->ac1, +, ddrout, ac0out, ac1in

** 45

   #+begin_src cpp
     #include <semaphore.h>
     #include <random>

     using namespace std;

     sem_t b1, b2, b3, d;
     default_random_engine *rep;

     void init() {
       sem_init(&d, 0, 1);
       sem_init(&b1, 0, 0);
       sem_init(&b2, 0, 0);
       sem_init(&b3, 0, 0);
       rep = new default_random_engine();
     }

     void boss() {
       sem_wait(&d);
       int ren = (*rep)() % 3;
       switch (ren) {
       case 0:
         sem_post(&b1);
         break;
       case 1:
         sem_post(&b2);
         break;
       case 2:
         sem_post(&b3);
       }
     }

     void p1() {sem_wait(&b1); sem_post(&d);}
     void p2() {sem_wait(&b2); sem_post(&d);}
     void p3() {sem_wait(&b3); sem_post(&d);}
   #+end_src


** 46
   : cache 效率: 完全 cache 时间 / 实际时间

*** 46.1

    tag: 5, index: 7, offset: 8

*** 46.2

    - 20124H: tag: 4H (00100), index: 1H, offset: 24H
    - 58100H: tag: bH (01011), index: 1H, offset: 0H
    - 60140H: tag: cH (01100), index: 1H, offset: 40H
    - 60138H: tag: cH (01100), index: 1H, offset: 38H

    124 能, 3 不能

    | 0 | 01100 |
    | 1 | 01011 |

*** 46.3

    - 5000 * 40ns + 200 * 160ns = 200000ns + 32000ns = 232000ns
    - 5200 * 40ns = 208000ns
    - 208000ns / 232000ns = 208/232 = 0.897

** 47

*** 47.1

    132: 1000 0100, 匹配 B, D, 最长匹配 B

*** 47.2

    124.150.71.132/32 | A

*** 47.3

    0.0.0.0/0 | E

*** 47.4

    | 142.150.64.0/26   | 255.255.255.192 | 142.150.64.1~142.150.64.62    |
    | 142.150.64.64/26  | 255.255.255.192 | 142.150.64.65~142.150.64.126  |
    | 142.150.64.128/26 | 255.255.255.192 | 142.150.64.129~124.150.64.190 |
    | 142.150.64.192/26 | 255.255.255.192 | 142.150.64.193~124.150.64.254 |
