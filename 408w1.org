* 选择
  1. a
  2. c
  3. a
  4. b
  5. d
  6. c I, II, IV
     - d
     - III: 最底层: 叶子节点不一定在最底层
  7. b
  8. c
  9. d
  10. b
  11. a
  12. a
  13. a
  14. d
  15. a
  16. c
  17. c
  18. d
  19. a
  20. a
  21. c
  22. d
      - c
      - dma 硬件控制, 不使用软件
  23. d
  24. d
  25. b
      - a
      - b 进程无法抢占 io2?
  26. b
  27. d
  28. c
  29. a
  30. c
  31. c
  32. d
  33. d
      - a
      - 网络分层不涉及具体实现
  34. b
  35. d
      - 滑动窗口大小: 发送窗口大小 + 接收窗口大小
  36. c
      - b
      - 右边 6 个?
  37. b
  38. a
  39. d
      - a
      - 怎么确定发起连接的 seq 是 X 还是 Y?
  40. c
* 大题
** 41
   - 前序: 24, 15, 05, 18, 22, 39, 26, 31
   - 中序: 05, 15, 18, 22, 24, 26, 31, 39
   - 后序: 05, 22, 18, 15, 31, 26, 39, 24
   - hash
     |----+----+----+---+----+----+----+---+---+----+----+----+----|
     |  0 |  1 |  2 | 3 |  4 |  5 |  6 | 7 | 8 |  9 | 10 | 11 | 12 |
     |----+----+----+---+----+----+----+---+---+----+----+----+----|
     | 39 | 26 | 15 |   | 05 | 18 | 31 |   |   | 22 |    | 24 |    |
     |----+----+----+---+----+----+----+---+---+----+----+----+----|
     |  1 |  2 |  1 |   |  3 |  1 |  2 |   |   |  1 |    |  1 |    |
     |----+----+----+---+----+----+----+---+---+----+----+----+----|
   - asl: (5*1 + 2*2 + 1*3) / 8 = 1.5
   - 堆: ((((15) 22 ()) 26 (18)) 39 ((24) 31 (05)))
** 42
*** 42.1
    记录层数的遍历, 没遍历到一个层数为 k 的节点时计数自增
*** 42.23
    #+begin_src cpp
      struct Tree {
        Tree *lc;
        Tree *rc;
      };

      int func(Tree *t, int k) {
        if (!t)
          return 0;
        if (!k)
          return 1;
        return func(t->lc, k - 1) + func(t->rc, k - 1);
      }
    #+end_src
** 43
   754 float: 1, 8, 23
*** 43.1
    - x 真值: 3g + 4
    - x/2 真值: 1g + 512m + 2
    - x/2 机器码: 6000 0002H
    - 2x 真值: 2g + 8
    - 2x 机器码: 8000 0008H
*** 43.2
    - x 真值: -1g + 4
    - x/2 真值: -512m + 2
    - x/2 机器码: E000 0002H
    - 2x 真值: -2g + 8
    - 2x 机器码: 8000 0008H
*** 43.3
    - x 真值: -2 - 1/(1m)
    - x/2 真值: -1 - 1/(2m)
    - x/2 机器码: BF80 0004H
    - 2x 真值: -4 - 2/(1m)
    - 2x 机器码: C080 0004H
** 44
*** 44.1
    - mov: 寄存器寻址到寄存器寻址
    - sta: 寄存器寻址到变址 / 基址寻址
    - lda: 直接寻址到寄存器寻址
*** 44.2
    - mov 最短: 寄存器到寄存器
    - sta 最长: 相比于 lda, sta 需要地址转换
    - 不会, sta 比 lda 多出地址转换的时间
*** 44.3
    1. f0f13cd2H
       - f0: 1111 0000, op = 11 1100 = 3cH, lda
       - op+基址 f0: 1111 00|00
       - 目标 f: 1111
       - 地址 13cd2: 0001 0011 1100 1101 0010
       - 合法: 把内存中地址为 13cd2H 的数据读取到寄存器 fH
    2. 2856H
       - 28: 0010 1000, op = 00 1010 = aH, mov
       - op+基址 28: 0010 10|00
       - 目标 5: 0101
       - 源 6: 0110
       - 合法: 把寄存器 6H 的数据移动到寄存器 5H
    3. 6dc6H
       - 6d: 0110 1101, op = 01 1011 = 1bH, sta
       - 不合法: 字长错误
    4. 1c2H
       - 01: 0000 0001, op = 00 0000 = 0H
       - 不合法: 未知 op
** 45
*** 45.1
    安全: 2134
*** 45.2
    分给 2: 分给 2 后仍为安全状态, 分给 1 后为不安全状态
*** 45.3
    没有立刻进入死锁状态
** 46
*** 46.1
    - 分解前
      - 512B / 64B = 2^3
      - 254 / 8 = 32
      - 33/2 = 16.5
    - 分解后
      - 512B / 16B = 2^5
      - 254 / 32 = 8
      - 9/2 + 1 = 5.5
*** 46.2
    - (n+1)/2 > (m+1)/2 + 1
    - n > m + 2
** 47
*** 47.1
    - a
      - 路由器: 202.38.60.64/26
      - a[1~10]: 202.38.60.[65~74]
    - b
      - 路由器: 202.38.60.128/26
      - b[1~8]: 202.38.60.[129~136]
    - c
      - 路由器: 202.38.61.0/24
      - c[1~5]: 202.38.61.[1~5]
*** 47.2
    |------------------+---+-------------|
    | 202.38.60.64/26  | a | 直接        |
    |------------------+---+-------------|
    | 202.38.60.128/26 | b | 直接        |
    |------------------+---+-------------|
    | 202.38.61.0/24   | c | 直接        |
    |------------------+---+-------------|
    | 61.0.0.0/8       | d | 直接        |
    |------------------+---+-------------|
    | 0.0.0.0/0        | d | 61.60.21.80 |
    |------------------+---+-------------|
*** 47.3
    202.38.60.191/26
*** 47.4
    202.38.61.255/24
