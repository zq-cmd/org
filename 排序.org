* 插入排序
** 直接插入排序
   - 查找 n 在 1~n-1 中的位置 k, k~n-1 后移, n 移至 k.
   - 适用于基本有序的少量数据.
   - 最好情况下, 每个元素只比较一次而补移动, o(n).
   - 复杂度: O(n^2).
** 折半插入排序
   - 类似插入排序, 查找 n 在 1~n-1 中的位置 k 用二分查找而非顺序查找.
   - 仅减少比较次数, 复杂度: O(n^2).
** 希尔排序
   - 将数据按下标模 n 同余分成 n 组, 每组直接插入排序, 后合并直接插入排序.
   - 复杂度: 当 n 在某范围内为 O(n^1.3), 最坏情况下为 O(n^2).
   - 不稳定, 且只适用于顺序表.
* 交换排序
** 冒泡排序
   - 从一端向另一端逐一比较相邻两元素, 若非排序顺序则交换, 确认最后一个元素.
   - 递归处理剩下 n-1 个元素.
   - 复杂度: 最坏情况和平均情况均为 O(n^2).
** 快速排序
   - 通常取第一个元素, 与其划分所有元素为两组.
   - 递归处理两组元素.
   - 虽然为内部排序, 但存在递归栈.
   - 复杂度取决于划分随机性.
   - 最坏的情况下, 空间复杂度为 O(n), 时间复杂度为 O(n^2).
   - 平均空间复杂度为 O(lgn), 时间复杂度为 O(nlgn).
   - 不稳定.
* 选择排序
** 简单选择排序
   - 在 i~n 中选择最小元素与 i 交换.
   - 复杂度: O(n^2).
   - 不稳定.
** 堆排序
   - 堆: 完全二叉树在顺序表中存储, 二叉树中任意结点优先级应高于其子结点.
   - 调整堆结点: 若结点子结点为堆, 结点优先级低于其子结点, 则与优先级
     最高的结点交换, 再递归调整被交换的结点, 调整后该结点构成堆.
   - 建堆: 所有叶结点构成堆, 调整子结点均构成堆的结点使其构成堆, 直至根结点构成堆.
   - 增加结点: 添加在最后, 递归调整新增结点的父结点直至根结点或不再发生变化.
   - 删除结点: 递归将其优先级最高的子结点替代被删除的结点.
   - 复杂度: O(nlgn).
   - 不稳定.
* 归并排序
  - 所有元素自成一组.
  - 每两组进行归并后形成新组.
  - 递归归并, 直至所有组归并为一组.
  - 外部排序, 空间复杂度为 O(n).
  - 时间复杂度为 O(nlgn).
* 比较
  | 算法         | 时间复杂度       | 空间复杂度 | 稳定 |
  |--------------+------------------+------------+------|
  | 直接插入排序 | O(n) O(n^2) ~    | O(1)       | 是   |
  | 冒泡排序     | O(n) O(n^2) ~    | O(1)       | 是   |
  | 简单选择排序 | O(n^2)           | O(1)       | 否   |
  | 希尔排序     |                  | O(1)       | 否   |
  | 堆排序       | O(nlgn)          | O(1)       | 否   |
  | 快速排序     | ~ O(nlgn) O(n^2) | O(lgn)     | 否   |
  | 归并排序     | O(nlgn)          | O(n)       | 是   |
