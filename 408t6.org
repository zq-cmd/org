* 选择
  1. c
  2. d
  3. b
  4. b
  5. a
  6. c
  7. b
  8. b
     - a?
     - 关键路径先求拓扑排序, 有环则无法求出拓扑排序, 求出拓扑排序则无环
  9. b
  10. c
  11. b
  12. d
  13. a
      - 截断法平均误差大, 实现简单
      - 舍入法平均误差小, 实现复杂
      - 恒置一法最大误差大
  14. d
      - I: 反码负数右移丢 0 影响精度?
  15. c
  16. c
  17. a
  18. b
  19. c
  20. d
      - c?
      - dma 方式传送一个数据占用一个存储周期而不是总线周期?
      - 总线传输频率大于内存存储频率?
  21. c
  22. a
  23. c
  24. d
  25. c
  26. d
  27. c
  28. b
  29. c
  30. d
  31. a
  32. a
  33. a
  34. d
  35. c
  36. c
      - 检测错误: 海明距为 n+1
      - 纠正错误: 海明距为 2*n+1
  37. a
  38. b
  39. d
  40. d
      - base64?
* 大题
** 41
   - tree1
     - 12 15
   - 18
     - 21 27
   - 31
     - 38 39 40
   - 45
     - 51 59 65 _67_ 69
   - 74
     - 77 84 89 96
   - tree2
     - 12 15
   - 18
     - 21 27
   - 31
     - 38 39 40
   - 45
     - 51 59
   - _65_
     - 67 69
   - 74
     - 77 84 89 96
   - tree3
     - tree3-1
       - 12 15
     - 18
       - 21 27
     - 31
       - 38 39 40
   - 45
     - tree3-2
       - 51 59
     - 65
       - 67 69
     - 74
       - 77 84 89 96
   - tree3
     - tree3-1
       - 12 15
     - 18
       - 21 27
     - 31
       - 38 39 40
   - 45
     - tree3-2
       - _51_ 59
     - 65
       - 67 69
     - 74
       - 77 84 89 96
   - tree4
     - tree4-1
       - 12 15
     - 18
       - 21 27
     - 31
       - 38 39 40
   - 45
     - tree4-2
       - 65 59 67 69
     - 74
       - 77 84 89 96
   - tree5
     - 12 15
   - 18
     - 21 27
   - 31
     - 38 39 40
   - 45
     - 65 59 67 69
   - 74
     - 77 84 89 96
** 42
*** 42.1
    1. 工作指针 ir1, ir2 指向 r 中第一个非负元素, 最后一个负元素, 初始值为 0, n-1
    2. ir1 自增, 重复直至 ir1 指向元素为非负或 ir1 = ir2, 若 ir1 = ir2, 则算法结束
    3. ir2 自减, 重复直至 ir2 指向元素为负或 ir1 = ir2, 若 ir1 = ir2, 则算法结束
    4. 交换 ir1 和 ir2 指向元素
    5. 重复 2, 3, 4
*** 42.2
    #+begin_src cpp
      void func(int *r, int n) {
        int ir1 = 0, ir2 = n - 1;
        while (1) {
          while (r[ir1] < 0)
            if (++ir1 == ir2)
              return;
          while (r[ir2] >= 0)
            if (--ir2 == ir1)
              return;
          int tmp = r[ir1];
          r[ir1] = r[ir2];
          r[ir2] = tmp;
        }
      }
    #+end_src
*** 42.3
    - 时间复杂度: O(n)
    - 空间复杂度: O(1)
** 43
*** 43.1
    4 * 275 * 12288B = 13200 KB = 12.9MB
*** 43.2
    - 最小
      - 275/5 = 55mm
      - 230/2 + 55 = 170mm = 0.17m
      - 12KB/(3.14 * 0.17^2 * 0.005 m^3) = 0.26 MB/m^3
    - 最大
      - 12KB/(3.14 * 0.115^2 * 0.005 m^3) = 0.51 MB/m^3
*** 43.3
    - 3000 r/min = 50 r/s
    - 1/50 s/r = 20 ms/r
    - 12KB/20ms = 0.6 KB/ms = 0.6 MB/s
*** 43.4
    1/2r * 20ms/r = 10ms
*** 43.5
    - 9 位磁道号 (柱面号)
    - 2 位盘面号 (磁头号)
    - 其后为磁道内偏移量 (扇区号)
** 44
*** 44.1
    - mar->m<->mbr
    - alu->移位器
    - c->alu
    - d->alu
    - 移位器, ir, pc, c, d, r0, r1, r2, r3 <-> 总线
*** 44.2
    - pc -> mar
    - m -> mbr -> ir
    - r1 -> mar
    - m -> mbr -> c
    - r2 -> mar
    - m -> mbr -> d
    - c, d -> alu -> 移位器 -> mbr -> m
    - r2 -> c
    - 1 -> d
    - c, d -> alu -> 移位器 -> r2
** 45
*** 45.1
    - 64K/16 = 4K
    - 4 * 4K = 16K
*** 45.2
    | 0 | 9 * 4K = 36K  |
    | 1 | 0 * 4K = 0K   |
    | 2 | 1 * 4K = 4K   |
    | 3 | 14 * 4K = 56K |
*** 45.3
    - [0, 0]: 36K+0 = 1001 0000 0000 0000
    - [1, 72]: 0K + 72 = 0000 0000 0100 1000
    - [2, 1023]: 4K + 1023 = 0000 1011 1111 1111
    - [3, 99]: 56K + 99 = 1110 0000 0110 0011
** 46
*** 46.1
    - 27/9 = 3ms/r
    - 30*8 + 5 = 245ms
*** 46.2
    - 隔一块存放
    - 6*8 + 5 = 53ms
** 47
   |  10.0.0.0 |  0 | 直接 |
   |  30.0.0.0 |  5 | R2   |
   |  40.0.0.0 |  3 | R2   |
   |  41.0.0.0 |  4 | R2   |
   |  45.0.0.0 |  4 | R8   |
   | 180.0.0.0 |  6 | R2   |
   | 190.0.0.0 | 10 | R5   |
